[0m[[0m[0mdebug[0m] [0m[0m> Exec(;Test/compile; collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(Test/compile, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Test / compile[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@5dae5a70, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"3","parents":[]},"eventTime":1643864110297,"message":"Compiling todocrud","dataKind":"compile-task","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0minfo[0m] [0m[0mcompiling 1 Scala source to C:\Users\gianc\Desktop\Revature\BigDataRepo\HWRepo\Project0\todocrud\target\scala-2.13\classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"compiling 1 Scala source to C:\\Users\\gianc\\Desktop\\Revature\\BigDataRepo\\HWRepo\\Project0\\todocrud\\target\\scala-2.13\\classes ..."})[0m
[0m[[0m[0minfo[0m] [0m[0mNon-compiled module 'compiler-bridge_2.13' for Scala 2.13.3. Compiling...[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Non-compiled module 'compiler-bridge_2.13' for Scala 2.13.3. Compiling..."})[0m
[0m[[0m[0minfo[0m] [0m[0m  Compilation completed in 6.575s.[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"  Compilation completed in 6.575s."})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118637,"message":"Compiling todocrud (15%)","total":26,"progress":15,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118639,"message":"Compiling todocrud (15%)","total":26,"progress":15,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118701,"message":"Compiling todocrud (30%)","total":26,"progress":30,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118704,"message":"Compiling todocrud (30%)","total":26,"progress":30,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118772,"message":"Compiling todocrud (50%)","total":26,"progress":50,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118773,"message":"Compiling todocrud (50%)","total":26,"progress":50,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118850,"message":"Compiling todocrud (65%)","total":26,"progress":65,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118851,"message":"Compiling todocrud (65%)","total":26,"progress":65,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118855,"message":"Compiling todocrud (80%)","total":26,"progress":80,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118855,"message":"Compiling todocrud (80%)","total":26,"progress":80,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118880,"message":"Compiling todocrud (100%)","total":26,"progress":100,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskProgress, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118880,"message":"Compiling todocrud (100%)","total":26,"progress":100,"dataKind":"compile-progress","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"}}})[0m
[0m[[0m[33mwarn[0m] [0m[0m4 deprecations (since 2.13.0); re-run with -deprecation for details[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":2,"message":"4 deprecations (since 2.13.0); re-run with -deprecation for details"})[0m
[0m[[0m[33mwarn[0m] [0m[0mone warning found[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":2,"message":"one warning found"})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/src/main/scala/Main.scala"},"buildTarget":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"3","parents":[]},"eventTime":1643864118914,"message":"Compiled todocrud","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Compile"},"errors":0,"warnings":0,"time":8617}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"4","parents":[]},"eventTime":1643864118987,"message":"Compiling todocrud-test","dataKind":"compile-task","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Test"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"4","parents":[]},"eventTime":1643864118992,"message":"Compiled todocrud-test","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/C:/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/#todocrud/Test"},"errors":0,"warnings":0,"time":5}})[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 9 s, completed Feb 2, 2022 11:55:19 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@34cf0e80, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\gianc\Desktop\Revature\BigDataRepo\HWRepo\Project0\todocrud\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Feb 2, 2022 11:55:19 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/src/main/scala/Main.scala"},"position":{"line":187,"character":4}}[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":1})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/src/main/scala/Main.scala"},"position":{"line":187,"character":4}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:     println("Which task would you like to delete? (Choose by TASK ID)")[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:     println("Which task would you like to delete? (Choose by TASK ID)")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol println[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol println[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/.metals/readonly/dependencies/scala-library-2.13.6-sources.jar/scala/Predef.scala","languageId":"scala","version":1,"text":"/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport scala.language.implicitConversions\n\nimport scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString\nimport scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION\nimport scala.annotation.meta.{ companionClass, companionMethod }\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  === Commonly Used Types ===\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]] and\n *  [[scala.collection.immutable.Set]].\n *\n *  === Console Output ===\n *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],\n *  which are aliases of the methods in the object [[scala.Console]].\n *\n *  === Assertions ===\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int = {\n *    require(nats forall (_ >= 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ >= 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  === Implicit Conversions ===\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n *\n * @groupname utilities Utility Methods\n * @groupprio utilities 10\n *\n * @groupname assertions Assertions\n * @groupprio assertions 20\n * @groupdesc assertions These methods support program verification and runtime correctness.\n *\n * @groupname console-output Console Output\n * @groupprio console-output 30\n * @groupdesc console-output These methods provide output via the console.\n *\n * @groupname aliases Aliases\n * @groupprio aliases 50\n * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.\n *\n * @groupname conversions-string String Conversions\n * @groupprio conversions-string 60\n * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.\n *\n * @groupname implicit-classes-any Implicit Classes\n * @groupprio implicit-classes-any 70\n * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.\n *\n * @groupname char-sequence-wrappers CharSequence Wrappers\n * @groupprio char-sequence-wrappers 80\n * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.\n *\n * @groupname conversions-java-to-anyval Java to Scala\n * @groupprio conversions-java-to-anyval 90\n * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.\n *\n * @groupname conversions-anyval-to-java Scala to Java\n * @groupprio conversions-anyval-to-java 100\n * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.\n *\n * @groupname conversions-array-to-wrapped-array Array to ArraySeq\n * @groupprio conversions-array-to-wrapped-array 110\n * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.\n */\nobject Predef extends LowPriorityImplicits {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass = classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] = class scala.collection.immutable.List\n   *\n   * val mapIntString = classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] = interface scala.collection.immutable.Map\n   * }}}\n   *\n   * @return The runtime [[Class]] representation of type `T`.\n   * @group utilities\n   */\n  def classOf[T]: Class[T] = null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /**\n   * Retrieve the single value of a type with a unique inhabitant.\n   *\n   * @example {{{\n   * object Foo\n   * val foo = valueOf[Foo.type]\n   * // foo is Foo.type = Foo\n   *\n   * val bar = valueOf[23]\n   * // bar is 23.type = 23\n   * }}}\n   * @group utilities\n   */\n  @inline def valueOf[T](implicit vt: ValueOf[T]): T = vt.value\n\n  /** The `String` type in Scala has all the methods of the underlying\n   *  [[java.lang.String]], of which it is just an alias.\n   *\n   *  In addition, extension methods in [[scala.collection.StringOps]]\n   *  are added implicitly through the conversion [[augmentString]].\n   *  @group aliases\n   */\n  type String        = java.lang.String\n  /**  @group aliases */\n  type Class[T]      = java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  /**  @group aliases */\n  type Function[-A, +B] = Function1[A, B]\n\n  /**  @group aliases */\n  type Map[K, +V] = immutable.Map[K, V]\n  /**  @group aliases */\n  type Set[A]     = immutable.Set[A]\n  /**  @group aliases */\n  val Map         = immutable.Map\n  /**  @group aliases */\n  val Set         = immutable.Set\n\n  /**\n   * Allows destructuring tuples with the same syntax as constructing them.\n   *\n   * @example {{{\n   * val tup = \"foobar\" -> 3\n   *\n   * val c = tup match {\n   *   case str -> i => str.charAt(i)\n   * }\n   * }}}\n   * @group aliases\n   */\n  val ->        = Tuple2\n\n  // Manifest types, companions, and incantations for summoning\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   = scala.reflect.OptManifest[T]\n  @implicitNotFound(msg = \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      = scala.reflect.Manifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          = scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        = scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T]): Manifest[T]          = m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] = m\n\n  // Minor variations on identity functions\n\n  /**\n   * A method that returns its input value.\n   * @tparam A type of the input value x.\n   * @param x the value of type `A` to be returned.\n   * @return the value `x`.\n   * @group utilities */\n  @inline def identity[A](x: A): A = x // see `$conforms` for the implicit version\n\n  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.\n   *\n   *  @tparam T the type of the value to be summoned\n   *  @return the implicit value of type `T`\n   *  @group utilities\n   */\n  @inline def implicitly[T](implicit e: T): T = e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n\n  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.\n   *  This is just a different name for [[identity]].\n   *\n   *  @example Separating code blocks from `new`:\n   *           {{{\n   *             val x = new AnyRef\n   *             {\n   *               val y = ...\n   *               println(y)\n   *             }\n   *             // the { ... } block is seen as the body of an anonymous class\n   *\n   *             val x = new AnyRef\n   *\n   *             {\n   *               val y = ...\n   *               println(y)\n   *             }\n   *             // an empty line is a brittle \"fix\"\n   *\n   *             val x = new AnyRef\n   *             locally {\n   *               val y = ...\n   *               println(y)\n   *             }\n   *             // locally guards the block and helps communicate intent\n   *           }}}\n   *  @group utilities\n   */\n  @inline def locally[T](@deprecatedName(\"x\") x: T): T = x\n\n  // assertions ---------------------------------------------------------\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean): Unit = {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: => Any): Unit = {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @group assertions\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean): Unit = {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.\n   *\n   *  @see [[scala.annotation.elidable elidable]]\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   *  @group assertions\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: => Any): Unit = {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @group assertions\n   */\n  def require(requirement: Boolean): Unit = {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   *  @group assertions\n   */\n  @inline final def require(requirement: Boolean, message: => Any): Unit = {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError when `???` is invoked.\n   *  @group utilities\n   */\n  def ??? : Nothing = throw new NotImplementedError\n\n  // implicit classes -----------------------------------------------------\n\n  /** @group implicit-classes-any */\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -> [B](y: B): (A, B) = (self, y)\n    @deprecated(\"Use `->` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.\", \"2.13.0\")\n    def â†’[B](y: B): (A, B) = ->(y)\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A = { assert(cond); self }\n    def ensuring(cond: Boolean, msg: => Any): A = { assert(cond, msg); self }\n    def ensuring(cond: A => Boolean): A = { assert(cond(self)); self }\n    def ensuring(cond: A => Boolean, msg: => Any): A = { assert(cond(self), msg); self }\n  }\n\n  /** @group implicit-classes-any */\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @inline def formatted(fmtstr: String): String = fmtstr format self\n  }\n\n  /** Injects String concatenation operator `+` to any classes. \n   * @group implicit-classes-any\n   */\n  @(deprecated @companionMethod)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\")\n  @(deprecated @companionClass)(\"Implicit injection of + is deprecated. Convert to String to call +\", \"2.13.0\") // for Scaladoc\n  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String = String.valueOf(self) + other\n  }\n\n  /** @group char-sequence-wrappers */\n  final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     = sequenceOfChars.length\n    def charAt(index: Int): Char                        = sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence = new SeqCharSequence(sequenceOfChars.slice(start, end))\n    override def toString                               = sequenceOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence = new SeqCharSequence(sequenceOfChars)\n\n  /** @group char-sequence-wrappers */\n  final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     = arrayOfChars.length\n    def charAt(index: Int): Char                        = arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence = new runtime.ArrayCharSequence(arrayOfChars, start, end)\n    override def toString                               = arrayOfChars.mkString\n  }\n\n  /** @group char-sequence-wrappers */\n  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence = new ArrayCharSequence(arrayOfChars)\n\n  /** @group conversions-string */\n  @inline implicit def augmentString(x: String): StringOps = new StringOps(x)\n\n  // printing -----------------------------------------------------------\n\n  /** Prints an object to `out` using its `toString` method.\n   *\n   *  @param x the object to print; may be null.\n   *  @group console-output\n   */\n  def print(x: Any): Unit = Console.print(x)\n\n  /** Prints a newline character on the default output.\n   *  @group console-output\n   */\n  def println(): Unit = Console.println()\n\n  /** Prints out an object to the default output, followed by a newline character.\n   *\n   *  @param x the object to print.\n   *  @group console-output\n   */\n  def println(x: Any): Unit = Console.println(x)\n\n  /** Prints its arguments as a formatted string to the default output,\n   *  based on a string pattern (in a fashion similar to printf in C).\n   *\n   *  The interpretation of the formatting patterns is described in\n   *  [[java.util.Formatter]].\n   *\n   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.\n   *\n   *  @param text the pattern for formatting the arguments.\n   *  @param xs   the arguments used to instantiate the pattern.\n   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments\n   *\n   *  @see [[scala.StringContext.f StringContext.f]]\n   *  @group console-output\n   */\n  def printf(text: String, xs: Any*): Unit = Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,\n  // in order to provide a more specific deprecation method.\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             = new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] = new runtime.Tuple3Zipped.Ops(x)\n\n  // Not specialized anymore since 2.13 but we still need separate methods\n  // to avoid https://github.com/scala/bug/issues/10746\n  // TODO: should not need @inline. add heuristic to inline factories for value classes.\n  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          = new ArrayOps(xs)\n  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] = new ArrayOps(xs)\n  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          = new ArrayOps(xs)\n  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          = new ArrayOps(xs)\n  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    = new ArrayOps(xs)\n  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       = new ArrayOps(xs)\n  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             = new ArrayOps(xs)\n  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          = new ArrayOps(xs)\n  @inline implicit def refArrayOps[T <: AnyRef](xs: Array[T]): ArrayOps[T]    = new ArrayOps(xs)\n  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       = new ArrayOps(xs)\n  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          = new ArrayOps(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  /** @group conversions-anyval-to-java */\n  implicit def byte2Byte(x: Byte): java.lang.Byte             = x.asInstanceOf[java.lang.Byte]\n  /** @group conversions-anyval-to-java */\n  implicit def short2Short(x: Short): java.lang.Short         = x.asInstanceOf[java.lang.Short]\n  /** @group conversions-anyval-to-java */\n  implicit def char2Character(x: Char): java.lang.Character   = x.asInstanceOf[java.lang.Character]\n  /** @group conversions-anyval-to-java */\n  implicit def int2Integer(x: Int): java.lang.Integer         = x.asInstanceOf[java.lang.Integer]\n  /** @group conversions-anyval-to-java */\n  implicit def long2Long(x: Long): java.lang.Long             = x.asInstanceOf[java.lang.Long]\n  /** @group conversions-anyval-to-java */\n  implicit def float2Float(x: Float): java.lang.Float         = x.asInstanceOf[java.lang.Float]\n  /** @group conversions-anyval-to-java */\n  implicit def double2Double(x: Double): java.lang.Double     = x.asInstanceOf[java.lang.Double]\n  /** @group conversions-anyval-to-java */\n  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean = x.asInstanceOf[java.lang.Boolean]\n\n  /** @group conversions-java-to-anyval */\n  implicit def Byte2byte(x: java.lang.Byte): Byte             = x.asInstanceOf[Byte]\n  /** @group conversions-java-to-anyval */\n  implicit def Short2short(x: java.lang.Short): Short         = x.asInstanceOf[Short]\n  /** @group conversions-java-to-anyval */\n  implicit def Character2char(x: java.lang.Character): Char   = x.asInstanceOf[Char]\n  /** @group conversions-java-to-anyval */\n  implicit def Integer2int(x: java.lang.Integer): Int         = x.asInstanceOf[Int]\n  /** @group conversions-java-to-anyval */\n  implicit def Long2long(x: java.lang.Long): Long             = x.asInstanceOf[Long]\n  /** @group conversions-java-to-anyval */\n  implicit def Float2float(x: java.lang.Float): Float         = x.asInstanceOf[Float]\n  /** @group conversions-java-to-anyval */\n  implicit def Double2double(x: java.lang.Double): Double     = x.asInstanceOf[Double]\n  /** @group conversions-java-to-anyval */\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean = x.asInstanceOf[Boolean]\n\n  /** An implicit of type `A => A` is available for all `A` because it can always\n   *  be implemented using the identity function. This also means that an\n   *  implicit of type `A => B` is always available when `A <: B`, because\n   *  `(A => A) <: (A => B)`.\n   */\n  // $ to avoid accidental shadowing (e.g. scala/bug#7788)\n  implicit def $conforms[A]: A => A = <:<.refl\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*/\n// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {\n  import mutable.ArraySeq\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef's MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          = new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short): runtime.RichShort       = new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int): runtime.RichInt             = new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char): runtime.RichChar          = new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long): runtime.RichLong          = new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       = new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    = new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean = new runtime.RichBoolean(x)\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] =\n    if (xs eq null) null\n    else ArraySeq.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T <: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let's share one.\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapRefArray[T <: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] = {\n    if (xs eq null) null\n    else if (xs.length == 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]\n    else new ArraySeq.ofRef[T](xs)\n  }\n\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt = if (xs ne null) new ArraySeq.ofInt(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble = if (xs ne null) new ArraySeq.ofDouble(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong = if (xs ne null) new ArraySeq.ofLong(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat = if (xs ne null) new ArraySeq.ofFloat(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar = if (xs ne null) new ArraySeq.ofChar(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte = if (xs ne null) new ArraySeq.ofByte(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort = if (xs ne null) new ArraySeq.ofShort(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean = if (xs ne null) new ArraySeq.ofBoolean(xs) else null\n  /** @group conversions-array-to-wrapped-array */\n  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit = if (xs ne null) new ArraySeq.ofUnit(xs) else null\n\n  /** @group conversions-string */\n  implicit def wrapString(s: String): WrappedString = if (s ne null) new WrappedString(s) else null\n}\n\nprivate[scala] abstract class LowPriorityImplicits2 {\n  @deprecated(\"Implicit conversions from Array to immutable.IndexedSeq are implemented by copying; Use the more efficient non-copying ArraySeq.unsafeWrapArray or an explicit toIndexedSeq call\", \"2.13.0\")\n  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] =\n    if (xs eq null) null\n    else new ArrayOps(xs).toIndexedSeq\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/gianc/Desktop/Revature/BigDataRepo/HWRepo/Project0/todocrud/.metals/readonly/dependencies/scala-library-2.13.6-sources.jar/scala/Predef.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨3, shutdown, null})[0m
